module_7_1
      Цель: закрепить знания о работе с файлами (чтение/запись) решив задачу.
    
    Задача "Учёт товаров":
    Необходимо реализовать 2 класса Product и Shop, с помощью которых будет производиться запись в файл с продуктами.
    Объекты класса Product будут создаваться следующим образом - Product('Potato', 50.0, 'Vagetables') и обладать следующими свойствами:
    Атрибут name - название продукта (строка).
    Атрибут weight - общий вес товара (дробное число) (5.4, 52.8 и т.п.).
    Атрибут category - категория товара (строка).
    Метод __str__, который возвращает строку в формате '<название>, <вес>, <категория>'. Все данные в строке разделены запятой с пробелами.
    
    Объекты класса Shop будут создаваться следующим образом - Shop() и обладать следующими свойствами:
    Инкапсулированный атрибут __file_name = 'products.txt'.
    Метод get_products(self), который считывает всю информацию из файла __file_name, закрывает его и возвращает единую строку со всеми товарами из файла __file_name.
    Метод add(self, *products), который принимает неограниченное количество объектов класса Product. Добавляет в файл __file_name каждый продукт из products, если его ещё нет в файле (по названию). Если такой продукт уже есть, то не добавляет и выводит строку 'Продукт <название> уже есть в магазине' .
    
    Пример результата выполнения программы:
    Пример работы программы:
    s1 = Shop()
    p1 = Product('Potato', 50.5, 'Vegetables')
    p2 = Product('Spaghetti', 3.4, 'Groceries')
    p3 = Product('Potato', 5.5, 'Vegetables')
    
    print(p2) # __str__
    
    s1.add(p1, p2, p3)
    
    print(s1.get_products())
    
    Вывод на консоль:
    Первый запуск:
    Spaghetti, 3.4, Groceries
    Potato, 50.5, Vegetables
    Spaghetti, 3.4, Groceries
    Potato, 5.5, Vegetables
    Второй запуск:
    Spaghetti, 3.4, Groceries
    Продукт Potato, 50.5, Vegetables уже есть в магазине
    Продукт Spaghetti, 3.4, Groceries уже есть в магазине
    Продукт Potato, 5.5, Vegetables уже есть в магазине
    Potato, 50.5, Vegetables
    Spaghetti, 3.4, Groceries
    Potato, 5.5, Vegetables
    
    Примечания:
    Не забывайте при записи в файл добавлять спец. символ перехода на следующую строку в конце - '\n'.
    При проверке на существование товара в методе add можно вызывать метод get_products для получения текущих продуктов.
    Не забывайте закрывать файл вызывая метод close() у объектов файла.

module_7_2
    Цель: Закрепить знания о позиционировании в файле, использовав метод tell() файлового объекта. Написать усовершенствованную функцию записи.

    Задача "Записать и запомнить":
    Создайте функцию custom_write(file_name, strings), которая принимает аргументы file_name - название файла для записи, strings - список строк для записи.
    Функция должна:
    Записывать в файл file_name все строки из списка strings, каждая на новой строке.
    Возвращать словарь strings_positions, где ключом будет кортеж (<номер строки>, <байт начала строки>), а значением - записываемая строка. Для получения номера байта начала строки используйте метод tell() перед записью.
    Пример полученного словаря:
    {(1, 0): 'Text for tell.', (2, 16): 'Используйте кодировку utf-8.'}
    Где:
    1, 2 - номера записанных строк.
    0, 16 - номера байт, на которых началась запись строк.
    'Text for tell.', 'Используйте кодировку utf-8.' - сами строки.
    
    Пример результата выполнения программы:
    Пример выполняемого кода:
    info = [
        'Text for tell.',
        'Используйте кодировку utf-8.',
        'Because there are 2 languages!',
        'Спасибо!'
        ]
    
    result = custom_write('test.txt', info)
    for elem in result.items():
      print(elem)
    
    Вывод на консоль:
    ((1, 0), 'Text for tell.')
    ((2, 16), 'Используйте кодировку utf-8.')
    ((3, 66), 'Because there are 2 languages!')
    ((4, 98), 'Спасибо!' 
    
    Примечания:
    Не забывайте при записи в файл добавлять спец. символ перехода на следующую строку в конце - '\n'.
    Не забывайте закрывать файл вызывая метод close() у объектов файла.
    Помните, что при использовании символов не принадлежащих таблице ASCII, вы используете больше байт для записи символа. Соответственно для чтения и записи информации из/в файл(-f) потребуется другая кодировка - utf-8.

module_7_3
    
    Цель: применить на практике оператор with, вспомнить написание кода в парадигме ООП.
    
    Задача "Найдёт везде":
    Напишите класс WordsFinder, объекты которого создаются следующим образом:
    WordsFinder('file1.txt, file2.txt', 'file3.txt', ...).
    Объект этого класса должен принимать при создании неограниченного количество названий файлов и записывать их в атрибут file_names в виде списка или кортежа.
    
    Также объект класса WordsFinder должен обладать следующими методами:
    get_all_words - подготовительный метод, который возвращает словарь следующего вида:
    {'file1.txt': ['word1', 'word2'], 'file2.txt': ['word3', 'word4'], 'file3.txt': ['word5', 'word6', 'word7']}
    Где:
    'file1.txt', 'file2.txt', ''file3.txt'' - названия файлов.
    ['word1', 'word2'], ['word3', 'word4'], ['word5', 'word6', 'word7'] - слова содержащиеся в этом файле.
    Алгоритм получения словаря такого вида в методе get_all_words:
    Создайте пустой словарь all_words.
    Переберите названия файлов и открывайте каждый из них, используя оператор with.
    Для каждого файла считывайте единые строки, переводя их в нижний регистр (метод lower()).
    Избавьтесь от пунктуации [',', '.', '=', '!', '?', ';', ':', ' - '] в строке. (тире обособлено пробелами, это не дефис в слове).
    Разбейте эту строку на элементы списка методом split(). (разбивается по умолчанию по пробелу)
    В словарь all_words запишите полученные данные, ключ - название файла, значение - список из слов этого файла.
    
    find(self, word) - метод, где word - искомое слово. Возвращает словарь, где ключ - название файла, значение - позиция первого такого слова в списке слов этого файла.
    count(self, word) - метод, где word - искомое слово. Возвращает словарь, где ключ - название файла, значение - количество слова word в списке слов этого файла.
    В методах find и count пользуйтесь ранее написанным методом get_all_words для получения названия файла и списка его слов.
    Для удобного перебора одновременно ключа(названия) и значения(списка слов) можно воспользоваться методом словаря - item().
    
    for name, words in get_all_words().items():
      # Логика методов find или count
    
    Пример результата выполнения программы:
    Представим, что файл 'test_file.txt' содержит следующий текст:
    
    
    Пример выполнения программы:
    finder2 = WordsFinder('test_file.txt')
    print(finder2.get_all_words()) # Все слова
    print(finder2.find('TEXT')) # 3 слово по счёту
    print(finder2.count('teXT')) # 4 слова teXT в тексте всего
    
    Вывод на консоль:
    {'test_file.txt': ["it's", 'a', 'text', 'for', 'task', 'найти', 'везде', 'используйте', 'его', 'для', 'самопроверки', 'успехов', 'в', 'решении', 'задачи', 'text', 'text', 'text']}
    {'test_file.txt': 3}
    {'test_file.txt': 4}
    
    Запустите этот код с другими примерами предложенными здесь.
    Если решение верное, то результаты должны совпадать с предложенными.
    
    Примечания:
    Регистром слов при поиске можно пренебречь. ('teXT' ~ 'text')
    Решайте задачу последовательно - написав один метод, проверьте результаты его работы.

format_string
    
    Цель задания:
    
    Освоить различные методы форматирования строк в Python.
    Научиться применять эти методы в контексте описания соревнования. История: соперничество двух команд - Мастера кода и Волшебники данных.
    
    Задание:
    Создайте новый проект или продолжите работу в текущем проекте.
    Напишите код, который форматирует строки для следующих сценариев.
    Укажите переменные, которые должны быть вставлены в каждую строку:
    
    Использование %:
    
    Переменные: количество участников первой команды (team1_num).
    Пример итоговой строки: "В команде Мастера кода участников: 5 ! "
    
    Переменные: количество участников в обеих командах (team1_num, team2_num).
    Пример итоговой строки: "Итого сегодня в командах участников: 5 и 6 !"
    
    Использование format():
    Переменные: количество задач решённых командой 2 (score_2).
    Пример итоговой строки: "Команда Волшебники данных решила задач: 42 !"
    
    Переменные: время за которое команда 2 решила задачи (team1_time).
    Пример итоговой строки: " Волшебники данных решили задачи за 18015.2 с !"
    
    Использование f-строк:
    Переменные: количество решённых задач по командам: score_1, score_2
    Пример итоговой строки: "Команды решили 40 и 42 задач.”
    
    Переменные: исход соревнования (challenge_result).
    Пример итоговой строки: "Результат битвы: победа команды Мастера кода!"
    
    Переменные: количество задач (tasks_total) и среднее время решения (time_avg).
    Пример итоговой строки: "Сегодня было решено 82 задач, в среднем по 350.4 секунды на задачу!."
    
    Комментарии к заданию:
    В русском языке окончания слов меняются (1 участник, 2 участника), пока что давайте не обращать на это внимания.
    Переменные challenge_result, tasks_total, time_avg можно задать вручную или рассчитать. Например, для challenge_result:
    if score_1 > score_2 or score_1 == score_2 and team1_time > team2_time:
    result = ‘Победа команды Мастера кода!’
    elif score_1 < score_2 or score_1 == score_2 and team1_time < team2_time:
    result = ‘Победа команды Волшебники Данных!’
    else:
    result = ‘Ничья!’
    
    Пример входных данных
    team1_num = 5
    team2_num = 6
    score_1 = 40
    score_2 = 42
    team1_time = 1552.512
    team2_time = 2153.31451
    tasks_total = 82
    time_avg = 45.2
    challenge_result = 'Победа команды Волшебники данных!'

module_7_4

    Цель задания:
    
    Освоить работу с файловой системой в Python, используя модуль os.
    Научиться применять методы os.walk, os.path.join, os.path.getmtime, os.path.dirname, os.path.getsize и использование модуля time для корректного отображения времени.
    
    Задание:
    
    Создайте новый проект или продолжите работу в текущем проекте.
    Используйте os.walk для обхода каталога, путь к которому указывает переменная directory
    Примените os.path.join для формирования полного пути к файлам.
    Используйте os.path.getmtime и модуль time для получения и отображения времени последнего изменения файла.
    Используйте os.path.getsize для получения размера файла.
    Используйте os.path.dirname для получения родительской директории файла.
    
    Комментарии к заданию:
    
    Ключевая идея – использование вложенного for
    
    for root, dirs, files in os.walk(directory):
      for file in files:
        filepath = ?
        filetime = ?
        formatted_time = time.strftime("%d.%m.%Y %H:%M", time.localtime(filetime))
        filesize = ?
        parent_dir = ?
        print(f'Обнаружен файл: {file}, Путь: {filepath}, Размер: {filesize} байт, Время изменения: {formatted_time}, Родительская директория: {parent_dir}')
    
    
    
    Так как в разных операционных системах разная схема расположения папок, тестировать проще всего в папке проекта (directory = “.”)
    Пример возможного вывода:
    Обнаружен файл: main.py, Путь: ./main.py, Размер: 111 байт, Время изменения: 11.11.1111 11:11, Родительская директория.
